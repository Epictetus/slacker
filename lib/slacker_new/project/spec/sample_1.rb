# Method describe opens up an example group.
describe 'My database' do
  # Simple example which demonstrates inline query against the database.
  it 'contains system tables' do
    # Select all system objects in the database.
    # We should have at least one of those.
    query_result = query("select * from sysobjects where xtype = 'S';")
    query_result.count.should > 0
  end

  # The same query, this time using a SQL template.
  # See file sql/sample_1/sysobject.sql.erb
  it 'contains system tables (take two)' do
    # SQL templates are located in the sql folder and are accessible through the "sql" object (see below).
    # Each sub-folder of the sql folder appears as a sql object contained within its parent startint at the root - the "sql" object.
    # Each template file (*.sql.erb) appears as a method of the folder it appears in.
    # 
    # For example, the file sysobjects.sql.erb is located in "sql/sample_1/",
    # so it is accessible like this:
    # sql.sample_1.sysobjects
    
    query_result = sql.sample_1.sysobjects
    query_result.count.should > 0
  end

  # This time we'll use a parameterized template.
  # See file sql/sample_1/sysobject_with_params.sql.erb
  it 'contains system tables (take three)' do
    # You can pass a hash to any SQL template - this hash becomes available to the
    # template through the "options" object - see file sql/sample_1/sysobject_with_params.sql.erb as an example.
    query_result = sql.sample_1.sysobjects_with_params(:xtype => 'S')
    query_result.count.should > 0
  end

  # Let's create a table and count our user objects which match this table name.
  # Every "it" (example) is executed in a transaction which is rolled back once the example is complete.
  # This ensures that every example starts at the same state of the database as any other example in the spec.
  # No example can ever interfere witht the results of another example.
  it 'contains a user table when one is created' do
    # Use inline query to create the table
    query('create table MyTable(id int, name varchar(100));')

    # Now lookup the table by type and name using a more elaborate dynamic SQL template.
    # See template sql/sample_1/sysobject_with_params_2.sql.erb
    query_result = sql.sample_1.sysobjects_with_params_2(:xtype => 'U', :name => 'MyTable')
    query_result.count.should == 1
  end

  # SQL Templates can contain multiple statements and can return multiple resultsets.
  it 'can play with numbers' do
    # Note that this time we're calling the template with a block.
    # When called with a block, a template is executed and its results are accessible
    # from within the block through the "results" object.
    sql.sample_1.play_with_numbers(:x => 2, :y => 12) do
      # The results object contains an array of all the resultsets generated by the query script.
      first_resultset = results[0]

      # A resultset contains an array of records.
      # Each record is a hash of field => value pairs.
      first_resultset[0][:product].should == 24

      # A resultset can be matched directly against an array of hashes using the "match" method.
      second_resultset = results[1]
      second_resultset.should match([{:x => 2, :y => 12, :sum => 14}])

      # Of course this works too:
      results[1].should match([{:x => 2, :y => 12, :sum => 14}])

      # Or a resultset's values can be matched one-by-one.
      # Note that the third resultset contains two records:
      third_resultset = results[2]
      third_resultset[0][:p].should == 2
      third_resultset[0][:s].should == 34
      third_resultset[1][:p].should == 12
      third_resultset[1][:s].should == 44
    end
  end

  # The results of a query can also be compared against the contents
  # of a CSV file located in the data folder - see file data/sample_1/numbers_expected_output.csv
  it 'can play with numbers (take two)' do
    sql.sample_1.play_with_numbers(:x => 10, :y => 34) do
      results[2].should match('sample_1/numbers_expected_output.csv')
    end
  end

  # CSV files can be used to load data directly into a table.
  # In this example, we will create a table, populate it with data,
  # execute standard deviation calculation and verify the results against
  # an expected result stored in a CSV file.
  it 'can play with numbers (take three)' do
    # Create the table - see file sql/sample_1/create_my_table.sql.erb
    sql.sample_1.create_my_table
    # We can populate any table by calling method "load_csv".
    # As a first parameter we will pass the name of the CSV file which contains the source data;
    # The file name is relative to the data folder - see file data/sample_1/my_table_initial_data.csv.
    # The name of the destination table goes into the second parameter.
    load_csv 'sample_1/my_table_initial_data.csv', 'MyTable'

    # Now let's test the system scalar function Power.
    # We will use it in a query expression executed agaings MyTable and we
    # will compare the results against a CSV file - we should expect them to match.
    # See files "sql/sample_1/my_table_on_power.sql.erb" and "data/sample_1/my_table_expected_power_results.csv"
    sql.sample_1.my_table_on_power.should match('sample_1/my_table_expected_power_results.csv')
  end
end
